> 책 "모던 JS Deep Dive" 2주차 정리 | 23.09.09 - 23.09.16

# **06장. 데이터 타입**

## 6.5 undefined 타입

undefined는 개발자가 의도적으로 할당하기 위한 값이 아니라, 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값이다.

변수에 값이 없다는 것을 명시하고 싶을 때는? undefined가 아니라 null을 할당하면 된다.

> **[선언(declaration)과 정의(definition)]**
선언 : 컴파일러에게 식별자의 존재만 알리는 것
정의 : 컴파일러가 변수를 생성해서 식별자와 메모리 주소를 연결
자바스크립트의 경우 변수를 선언하면 암묵적으로 정의가 이뤄지기 때문에 선언과 정의의 구분이 모호하다.
> 

## 6.6 null 타입

null은 변수에 값이 없다는 것을 의도적으로 명시(의도적 부재 - intentional absence)할 때 사용한다.

변수에 null을 할당하는 것은 **변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미**다. 이는 이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거하는 것을 의미하며, 자바스크립트 엔진은 누구도 참조하지 않는 메모리 공간에 대해 가비지 콜렉션을 수행할 것이다.

## 6.7 심벌 타입

심벌은 ES6에 추가된 7번 째 타입으로, 변경 불가능한 원시 타입의 값이다.

주로 **이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키**를 만들기 위해 사용한다.

```jsx
// 심벌 값 생성
var key = Symbol('key');
console.log(typeof key); // symbol

// 객체 생성
var obj = {};

// 이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용
obj[key] = 'value'
console.log(obj[key]); // value
```

## 6.8 객체 타입

자바스크립트는 객체 기반의 언어이며, 자바스크립트를 이루고 있는 거의 모든 것이 객체다.

## 6.9 데이터 타입의 필요성

### 6.9.1 데이터 타입에 의한 메모리 공간의 확보와 참조

자바스크립트 엔진은 데이터 타입, 즉 값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다.

즉, 변수에 할당되는 값의 데이터 타입에 따라 확보해야 할 메모리 공간의 크기가 결정된다.

### 6.9.2 데이터 타입에 의한 값의 해석

모든 값은 데이터 타입을 가지며, 메모리에 2진수, 즉 비트의 나열로 저장된다.

데이터 타입이 필요한 이유

- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
- 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

## 6.10 동적 타이핑

### 6.10.1 동적 타입 언어와 정적 타입 언어

C나 자바 같은 **정적 타입(static/strong type)** 언어는 변수를 선언할 때, 변수에 할당할 수 있는 값의 종류, 즉 데이터 타입을 사전에 선언해야 한다. 이를 **명시적 타입 선언(explicit type declaration)**이라 한다.

```cpp
char c;
int num;
```

타입의 일관성을 강제함으로써 더욱 안정적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄인다.

자바스크립트는 정적 타입 언어와 다르게 변수를 선언할 때, 타입을 선언하지 않는다. 다만 var, let, const 키워드를 사용해 변수를 선언할 뿐이다.

자바스크립트의 변수는 선언이 아닌 할당에 의해 **타입이 결정(타입 추론 - type inference)**된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다. 이러한 특징을 **동적 타이핑(dynamic typing)**

### 6.10.2 동적 타입 언어와 변수

**[동적 타입의 단점]**

1. 변화하는 변수 값을 추적하기 어려울 수 있다.
2. 동적 타입 언어의 변수는 값의 변경에 의해 타입도 언제든지 변경될 수 있다.
3. 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되기도 한다.

⇒ 유연성(flexibility)은 높지만, 신뢰성(reliability)은 떨어진다.

**[변수 사용할 때, 주의사항]**

1. 변수의 무분별한 남발은 금물이며, 필요한 만큼 최소한으로 유지해야 한다.
2. 변수의 유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제해야 한다.
3. 전역 변수는 최대한 사용하지 않도록 한다.
4. 변수보다는 상수(const)를 사용해 값의 변경을 억제한다.
5. 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다.

---

# 07장. 연산자

연산자(operator)는 값으로 평가된 피연산자(operand)를 연산해 새로운 값을 만든다.

## 7.1 산술 연산자

### 7.1.1 이항 산술 연산자

2개의 피연산자를 산순 연산하여 숫자 값을 만든다.

| 이항 산술 연산자 | 의미 | 부수 효과 |
| --- | --- | --- |
| + | 덧셈 | X |
| - | 뺄셈 | X |
| * | 곱셈 | X |
| / | 나눗셈 | X |
| % | 나머지 | X |

피연산자의 값이 바뀌는 경우는 없고 언제나 새로운 값을 만들 뿐이다.

### 7.1.2 단항 산술 연산자

| 단항 산술 연산자 | 의미 | 부수 효과 |
| --- | --- | --- |
| ++ | 증가 | O |
| -- | 감소 | O |
| + | 어떠한 효과도 없다.
음수를 양수로 반전하지도 않는다. | X |
| - | 양수를 음수로, 음수를 양수로
반전한 값을 반환한다. | X |

```jsx
var x = 5, result;

// 선할당 후증가
result = x++;
console.log(result, x); // 5 6

// 선증가 후할당
result = ++x;
console.log(result, x); // 7 7
```

+ 단항 연산자는 피연산자에 어떠한 효과도 없다. 숫자 타입이 아닌 피연산자에 + 단항 연산자를 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다.

```jsx
var x = '1';
console.log(+x); // 1
console.log(x); // "1"

x = true;
console.log(+x); // 1
console.log(x); // true

// 문자열을 숫자로 타입 변환할 수 없으므로 NaN 반환
x = 'Hello';
console.log(+x); // NaN
```

### 7.1.3 문자열 연결 연산자

```jsx
'1' + 2; // '12'
1 + '2'; // '12'

1 + true; // 2
1 + false; // 1

+undefined; // NaN
1 + undefined; // NaN
```

## 7.2 할당 연산자

| 할당 연산자 | 예 | 동일 표현 | 부수 효과 |
| --- | --- | --- | --- |
| = | x = 5 | x = 5 | O |
| += | x += 5 | x = x + 5 | O |
| -= | x -= 5 | x = x - 5 | O |
| *= | x *= 5 | x = x * 5 | O |
| /= | x /= 5 | x = x / 5 | O |
| %= | x %= 5 | x = x % 5 | O |

할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다.

## 7.3 비교 연산자

### 7.3.1 동등/일치 비교 연산자

| 비교 연산자 | 의미 | 사례 | 설명 | 부수 효과 |
| --- | --- | --- | --- | --- |
| == | 동등 비교 | x == y | x와 y의 값이 같음 | X |
| === | 일치 비교 | x === y | x와 y의 값과 타입이 같음 | X |
| != | 부동등 비교 | x != y | x와 y의 값이 다름 | X |
| !== | 불일치 비교 | x !== y | x와 y의 값과 타입이 다름 | X |

```jsx
// NaN은 자신과 일치하지 않는 유일한 값이다.
NaN === NaN; // false

Number.isNaN(NaN); // true

0 === -0 // true
0 == -0 // true
```

**[[Object.is](http://Object.is) 메서드]**

다음과 같이 예측 가능한 정확한 비교 결과를 반환한다. 그 외에는 일치 비교 연산자(===)와 동일하게 동작한다.

```jsx
-0 === +0; // true
Object.is(-0, +0); // false

NaN === NaN; // false
Object.is(NaN, NaN); // true
```

### 7.3.2 대소 관계 비교 연산자

## 7.4 삼항 조건 연산자

> 조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값
> 

`삼항 조건 연산자 표현식`은 값처럼 사용할 수 있지만, `if … else` 문은 값처럼 사용할 수 없다.

`삼항 조건 연산자 표현식`은 값으로 평가할 수 있는 표현식인 문이다. 그래서 값처럼 다른 표현식의 일부가 될 수 있어 매우 유용하다.

## 7.5 논리 연산자

| 논리 연산자 | 의미 | 부수 효과 |
| --- | --- | --- |
| || | 논리합(OR) | X |
| && | 논리곱(AND) | X |
| ! | 부장(NOT) | X |

**[드 모르간의 법칙]**

```jsx
!(x || y) === (!x && !y)
!(x && y) === (!x || !y)
```

## 7.6 쉼표 연산자

쉼표(`,`) 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.

```jsx
var x, y, z;
x =1, y = 2, z = 3; // 3
```

## 7.7 그룹 연산자

소괄호(’`( )`’)로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가한다.

## 7.8 typeof 연산자

```jsx
typeof null // "object" => 자바스크립트의 첫 번째 버그
typeof [] // "object"
```

값이 null 타입인지 확인할 때는 `typeof` 연산자를 사용하지 말고 `일치 연산자`(===)를 사용하자.

```jsx
// undeclared 식별자를 선언한 적이 없다.
typeof undeclared; // undefiend
```

선언하지 않은 식별자를 typeof 연산자로 연산해 보면 `ReferenceError`가 발생하지 않고 `undefined`를 반환한다.

## 7.9 지수 연산자

ES7에서 도입된 지수 연산자는 좌황의 피연산자를 밑(base)으로, 우항의 피연산자를 지수(exponent)로 거듭 제곱하여 숫자 값을 반환한다.

```jsx
// 지수 연산자가 도입되기 이전에 사용
Math.pow(2, 2); // 4

// 가독성이 더 좋다.
2 ** 2; // 4

// 음수를 base로 사용하려면, 괄호로 묶어야 된다.
(-5) ** 2; // 25
```

할당 연산자와 함께 사용할 수 있다.

```jsx
var num = 5;
num **= 2; // 25
```

## 7.10 그 외의 연산자

## 7.11 연산자의 부수 효과

할당 연산자(`=`), 증가/감소 연산자(`++`/`--`), `delete` 연산자

## 7.12 연산자 우선순위

1. ()
2. …
3. ==, !=, ===, !==

## 7.13 연산자 결합 순서

---

# 08장. 제어문

제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있다. 제어문은 코드의 흐름을 이해하기 어렵게 만들어 가독성을 해치는 단점이 있는데 이는 오류를 발생시키는 원인이 된다. 나중에 `forEach`, `map`, `filter`, `reduce` 같은 고차 함수를 사용한 함수형 프로그래밍 기법에서는 제어문의 사용을 억제하여 복잡성을 해결하려고 노력한다.

## 8.1 블록문

블록문(block / compound statement)은 0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라고 부르기도 한다. 자바스크립트는 블록문을 하나의 실행 단위로 취급한다.

## 8.2 조건문

### 8.2.1 if … else 문

```jsx
if (조건식) {
	// 조건식이 참이면 이 코드 블록이 실행된다.
} else {
	// 조건식이 거짓이면 이 코드 블록이 실행된다.
}
```

### 8.2.2 switch 문

```jsx
switch (표현식) {
	case 표현식1:
		break;
	case 표현식2:
		break;
	default:
}
```

폴스루(`fall through`) : switch 문이 끝날 때까지 이후의 모든 case 문과 default 문을 실행하는 것

⇒ break 문을 사용하지 않았기 때문에 이러한 현상이 나타난다.

default 문에는 break 문을 생략하는 것이 일반적이다.

## 8.3 반복문

### 8.3.1 for 문

```jsx
for (변수 선언문 또는 할당문; 조건식; 증감식) {
	조건문이 참인 경우 반복 실행될 문;
}
```

### 8.3.2 while 문

```jsx
var count = 0;

while(true) {
	console.log(count);
	count++;
	// count가 3이면, 코드 블록을 탈출한다.
	if(count === 3) break;
} // 0 1 2
```

### 8.3.3 do … while 문

```jsx
var count = 0;

do {
	console.log(count); // 0 1 2
	count++;
} while (count < 3);
```

## 8.4 break 문

레이블 문, 반복문(for, for … in, for … of, while, do … while) 또는 switch 문의 코드 블록을 탈출한다.

레이블 문(`label statement`)이란 식별자가 붙은 문을 말한다.

```jsx
foo: {
	console.log(1);
	break foo;
	console.log(2);
}

console.log('Done!');
```

레이블 문은 중첩된 for 문 외부로 탈출할 때, 유용하지만 그 밖의 경우에는 일반적으로 권장하지 않는다. 레이블 문을 사용하면 프로그램의 흐름이 복잡해져서 가독성이 나빠지고 오류를 발생시킬 가능성이 높아지기 때문이다.

## 8.5 continue 문

반복문의 코드 블록 실행을 현 시점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다. break 문처럼 반복문을 탈출하지 않는다.

```jsx
var string = "Hello World.";

for (var i = 0; i < string.length; i++) {
	// 'l'이 아니면 카운트를 증가시키지 않는다.
	if (string[i] !== search) continue;
	
	count++;
	// code
}
```

---

# 09장. 타입 변환과 단축 평가

## 9.1 타입 변환이란?

**명시적 타입 변환(explicit coercion) 또는 타입 캐스팅(type casting)**
: 개발자가 의도적으로 값의 타입을 변환하는 것

**암묵적 타입 변환(implicit coercion) 또는 타입 강제 변환(type coercion)**
: 개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환된다.
